/**
 * @author Bill Riehl <wjriehl@lbl.gov>
 * @public
 */

define(['kbwidget', 'bootstrap', 'jquery', 'narrativeConfig', 'kbaseNarrativeInput'], (
    KBWidget,
    bootstrap,
    $,
    Config,
    kbaseNarrativeInput
) => {
    'use strict';
    return KBWidget({
        name: 'kbaseDefaultNarrativeInput',
        parent: kbaseNarrativeInput,
        version: '1.0.0',
        options: {
            loadingImage: Config.get('loading_gif'),
        },

        init: function (options) {
            this._super(options);

            this.render();
            this.refresh();
            return this;
        },

        useSelect2: true,

        /**
         * Builds the input div for a function cell, based on the given method object.
         * @param {Object} method - the method being constructed around.
         * @returns {String} an HTML string describing the available parameters for the cell.
         * @private
         */
        render: function () {
            // figure out all types from the method
            const method = this.options.method;
            const params = method.properties.parameters;

            let inputDiv = "<div class='kb-cell-params'><table class='table'>";
            for (let i = 0; i < Object.keys(params).length; i++) {
                const pid = 'param' + i;
                const p = params[pid];

                const input_default =
                    p.default !== '' && p.default !== undefined
                        ? " placeholder='" + p.default + "'"
                        : '';
                const input =
                    "<input class='form-control' style='width: 95%' name='" +
                    pid +
                    "'" +
                    input_default +
                    " value='' type='text'></input>";

                const cellStyle = 'border:none; vertical-align:middle;';
                inputDiv +=
                    "<tr style='" +
                    cellStyle +
                    "'>" +
                    "<th style='" +
                    cellStyle +
                    " font-family: 'OxygenBold', sans-serif; font-weight: bold;>" +
                    p.ui_name +
                    '</th>' +
                    "<td style='" +
                    cellStyle +
                    " width: 40%;'>" +
                    input +
                    '</td>' +
                    "<td style='" +
                    cellStyle +
                    " color: #777;'>" +
                    p.description +
                    '</td>' +
                    '</tr>';
            }
            inputDiv += '</table></div>';
            this.$elem.append(inputDiv);
        },

        /**
         * Returns a list of parameters in the order in which the given method
         * requires them.
         * @return {Array} an array of strings - one for each parameter
         * @public
         */
        getParameters: function () {
            const paramList = [];

            $(this.$elem)
                .find('[name^=param]')
                .filter(':input')
                .each((_key, field) => {
                    let value = field.value;
                    if (!value) value = field.placeholder;
                    paramList.push(value.trim());
                });

            return paramList;
        },

        /**
         * Returns an object representing the state of this widget.
         * In this particular case, it is a list of key-value pairs, like this:
         * {
         *   'param0' : 'parameter value',
         *   'param1' : 'parameter value'
         * }
         * with one key/value for each parameter in the defined method.
         */
        getState: function () {
            const state = {};

            $(this.$elem)
                .find('[name^=param]')
                .filter(':input')
                .each((_key, field) => {
                    state[field.name] = field.value;
                });

            return state;
        },

        /**
         * Adjusts the current set of parameters based on the given state.
         * Doesn't really do a whole lot of type checking yet, but it's assumed that
         * a state will be loaded from an object generated by getState.
         */
        loadState: function (state) {
            if (!state) return;

            $(this.$elem)
                .find('[name^=param]')
                .filter(':input')
                .each((_key, field) => {
                    const $field = $(field);
                    const fieldName = $field.attr('name');

                    // If it's a text field, just dump the value in there.
                    // If it's a select field, do the same.
                    if (
                        ($field.is('input') && $field.attr('type') === 'text') ||
                        $field.is('select')
                    ) {
                        $field.val(state[fieldName]);
                    }
                });
        },

        /**
         * Refreshes the input fields for this widget. I.e. if any of them reference workspace
         * information, those fields get refreshed without altering any other inputs.
         */
        refresh: function () {
            const method = this.options.method;
            const params = method.properties.parameters;
            const lookupTypes = [];
            const tempObj = {};
            for (const p in params) {
                if (!tempObj.hasOwnProperty(params[p].type)) {
                    lookupTypes.push(params[p].type);
                    tempObj[params[p].type] = 1;
                }
            }

            this.trigger('dataLoadedQuery.Narrative', [
                lookupTypes,
                this.IGNORE_VERSION,
                $.proxy(function (objects) {
                    // we know from each parameter what each input type is.
                    // we also know how many of each type there is.
                    // so, iterate over all parameters and fulfill cases as below.

                    for (let i = 0; i < Object.keys(params).length; i++) {
                        const pid = 'param' + i;
                        const p = params[pid];

                        // we're refreshing, not rendering, so assume that there's an
                        // input with name = pid present.
                        const $input = $($(this.$elem).find('[name=' + pid + ']'));
                        let objList = [];

                        /*
                         * New sorting - by date, then alphabetically within dates.
                         */
                        if (objects[p.type] && objects[p.type].length > 0) {
                            objList = objects[p.type];
                            objList.sort((a, b) => {
                                if (a[3] > b[3]) return -1;
                                if (a[3] < b[3]) return 1;
                                if (a[1] < b[1]) return -1;
                                if (a[1] > b[1]) return 1;
                                return 0;
                            });
                        }

                        /* down to cases:
                         * 1. (simple) objList is empty, $input doesn't have a list attribute.
                         * -- don't do anything.
                         * 2. objList is empty, $input has a list attribute.
                         * -- no more data exists, so remove that list attribute and the associated datalist element
                         * 3. objList is not empty, $input doesn't have a list attribute.
                         * -- data exists, new datalist needs to be added and linked.
                         * 4. objList is not empty, $input has a list attribute.
                         * -- datalist needs to be cleared and updated.
                         */

                        // case 1 - no data, input is unchanged

                        // case 2 - no data, need to clear input
                        let datalistID = $input.attr('list');
                        if (objList.length == 0 && datalistID) {
                            $(this.$elem.find('#' + datalistID)).remove();
                            $input.removeAttr('list');
                            $input.val('');
                        }

                        // case 3 - data, need new datalist
                        // case 4 - data, need to update existing datalist
                        else if (objList.length > 0) {
                            let $datalist;
                            if (!datalistID) {
                                datalistID = this.genUUID();
                                $input.attr('list', datalistID);
                                $datalist = $('<datalist>').attr('id', datalistID);
                                $input.after($datalist);
                            } else {
                                $datalist = $(this.$elem.find('#' + datalistID));
                            }
                            $datalist.empty();
                            for (const element of objList) {
                                $datalist.append(
                                    $('<option>').attr('value', element[1]).append(element[1])
                                );
                            }
                        }
                    }
                }, this),
            ]);
        },

        genUUID: function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = (Math.random() * 16) | 0,
                    v = c == 'x' ? r : (r & 0x3) | 0x8;
                return v.toString(16);
            });
        },
    });
});
